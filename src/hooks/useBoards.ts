import { useState, useEffect, useCallback } from 'react';
import { supabase } from '../supabaseClient';
import { Board } from '../types';

export const useBoards = (
    onBoardSwitch?: () => void
) => {
    const [boards, setBoards] = useState<Board[]>([]);
    const [currentBoardId, setCurrentBoardId] = useState<string | null>(null);

    // Fetch Boards
    useEffect(() => {
        const fetchBoards = async () => {
            const { data, error } = await supabase.from('boards').select('*').order('created_at', { ascending: true });

            if (data && data.length > 0) {
                setBoards(data);
                // Default to first board if none selected (or handle externally)
                if (!currentBoardId) setCurrentBoardId(data[0].id);
            } else {
                // If no boards, create default
                const defaultBoard = { id: 'case-default', name: 'Main Case' };
                // Check if we can create it (or if it's strictly RLS)
                // For now, assume we can insert if table exists.
                // If table doesn't exist, this might fail, but requirements imply table `boards` exists.
                const { data: newBoard, error: insertError } = await supabase.from('boards').insert(defaultBoard).select();
                if (newBoard) {
                    setBoards(newBoard);
                    setCurrentBoardId(newBoard[0].id);
                } else if (!data) {
                    // Fallback local state if DB fails (e.g. offline)
                    setBoards([defaultBoard]);
                    setCurrentBoardId(defaultBoard.id);
                }
            }
        };

        fetchBoards();
    }, []);

    const addBoard = useCallback(async () => {
        const newBoard = {
            // id: auto-generated by DB usually, but if we need UUID:
            // Let's rely on DB default or generate one if needed. 
            // Supabase usually has `id uuid default gen_random_uuid()`
            // But if we want to be safe, we can omit ID if column is auto-inc/uuid.
            // Let's assume we provide title.
            name: `New Case #${boards.length + 1}`
        };

        const { data, error } = await supabase.from('boards').insert(newBoard).select();
        if (data) {
            setBoards(prev => [...prev, data[0]]);
            setCurrentBoardId(data[0].id);
            if (onBoardSwitch) onBoardSwitch();
        }
    }, [boards, onBoardSwitch]);

    const renameBoard = useCallback(async (id: string, newName: string) => {
        const { error } = await supabase.from('boards').update({ name: newName }).eq('id', id);
        if (!error) {
            setBoards(prev => prev.map(b => b.id === id ? { ...b, name: newName } : b));
        }
    }, []);

    const deleteBoard = useCallback(async (id: string) => {
        if (!window.confirm("Are you sure? This will delete all evidence in this case!")) return;

        // Cascade delete in DB usually handles notes, but if not:
        // We might need to delete notes first. 
        // Requirement says: "Delete board and its related notes/connections".
        // Let's assume manual cleanup to be safe unless we key foreign keys with CASCADE.
        await supabase.from('notes').delete().eq('board_id', id);
        await supabase.from('connections').delete().eq('board_id', id);

        const { error } = await supabase.from('boards').delete().eq('id', id);

        if (!error) {
            const nextBoards = boards.filter(b => b.id !== id);
            setBoards(nextBoards);
            if (currentBoardId === id) {
                setCurrentBoardId(nextBoards.length > 0 ? nextBoards[0].id : null);
                if (onBoardSwitch) onBoardSwitch();
            }
        }
    }, [boards, currentBoardId, onBoardSwitch]);

    return {
        boards,
        currentBoardId,
        setCurrentBoardId,
        addBoard,
        renameBoard,
        deleteBoard
    };
};
